diff -Naur a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2015-04-29 13:44:35.000000000 +0000
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2015-05-29 19:38:13.740232944 +0000
@@ -53,6 +53,7 @@
 #include "DVDStreamInfo.h"
 #include "settings/GUISettings.h"
 #include "utils/SystemInfo.h"
+#include "Video/DVDVideoCodecMFC.h"
 
 CDVDVideoCodec* CDVDFactoryCodec::OpenCodec(CDVDVideoCodec* pCodec, CDVDStreamInfo &hints, CDVDCodecOptions &options )
 {
@@ -169,9 +170,16 @@
 #elif defined(_LINUX) && !defined(TARGET_DARWIN)
   hwSupport += "VAAPI:no ";
 #endif
+hwSupport += "MFC:yes ";
 
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
+  if ( !hint.software ) {
+    if ( hint.codec == CODEC_ID_H263 || hint.codec == CODEC_ID_H264 || hint.codec == CODEC_ID_MPEG4 || hint.codec == CODEC_ID_MPEG2VIDEO || CODEC_ID_MPEG1VIDEO || hint.codec == CODEC_ID_VC1 ) {
+      if( (pCodec = OpenCodec(new CDVDVideoCodecMFC(), hint, options)) ) return pCodec;
+    }
+  }  
+  
   // dvd's have weird still-frames in it, which is not fully supported in ffmpeg
   if(hint.stills && (hint.codec == CODEC_ID_MPEG2VIDEO || hint.codec == CODEC_ID_MPEG1VIDEO))
   {
diff -Naur a/xbmc/cores/dvdplayer/DVDCodecs/Video/CMakeLists.txt b/xbmc/cores/dvdplayer/DVDCodecs/Video/CMakeLists.txt
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/CMakeLists.txt	2015-04-29 13:44:35.000000000 +0000
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/CMakeLists.txt	2015-05-30 08:43:15.609851459 +0000
@@ -1,8 +1,10 @@
+set(video_SRCS ./deinterleave_chroma.neon.S)
 find_all_sources(. video_SRCS)
 list(REMOVE_ITEM video_SRCS ./DVDVideoCodecOpenMax.cpp)
 list(REMOVE_ITEM video_SRCS ./DVDVideoCodecVideoToolBox.cpp)
 list(REMOVE_ITEM video_SRCS ./OpenMaxVideo.cpp)
 list(REMOVE_ITEM video_SRCS ./OpenMax.cpp)
+list(APPEND video_SRCS ${root}/xbmc/cores/dvdplayer/DVDCodecs/Video/deinterleave_chroma.neon.S)
 
 if(NOT TARGET_WIN32)
 	list(REMOVE_ITEM video_SRCS ./DXVA.cpp)
diff -Naur a/xbmc/cores/dvdplayer/DVDCodecs/Video/deinterleave_chroma.neon.S b/xbmc/cores/dvdplayer/DVDCodecs/Video/deinterleave_chroma.neon.S
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/deinterleave_chroma.neon.S	1970-01-01 00:00:00.000000000 +0000
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/deinterleave_chroma.neon.S	2015-05-29 19:24:44.000000000 +0000
@@ -0,0 +1,34 @@
+#ifdef __ARM_NEON__
+  .text
+  .align  2
+  .global deinterleave_chroma_neon
+  .type   deinterleave_chroma_neon, %function
+
+#define U       r0
+#define V       r1
+#define UV      r2
+#define WIDTH   r3
+#define HEIGHT  r4
+#define COUNT   r5
+
+deinterleave_chroma_neon:
+  .fnstart
+  push    {r4-r5,lr}                       // save r4,r5,lr in stack. 3 words
+  ldr     HEIGHT, [sp, #3*4]               // copy 4-th stack element to r4 (HEIGHT)
+
+  cmp     HEIGHT,  #0                      // compare HEIGHT == 0
+process_line:
+  pople   {r4-r5,pc}                       // if last comparsion result <=0 then pop r4,r5,lr from stack will be written to pc (that means exit and continue code called .S)
+  mov     COUNT,   WIDTH                   // COUNT = WIDTH
+process_block:
+  pld     [UV]                             // Preload data from UV (signal processor that this data will most likely be loaded soon)
+  vld2.u8 {d0,d1}, [UV]!                   // load 16-byte block from UV setting d0 as odd and d1 as even half-blocks, increment UV address by 16
+  subs    COUNT,   COUNT, #8               // COUNT = COUNT - 8, compare COUNT to 0
+  vst1.u8 {d0},    [U]!                    // unload 8-byte block d0 to U, increment U address by 8
+  vst1.u8 {d1},    [V]!                    // unload 8-byte block d1 to V, increment V address by 8
+  bgt     process_block                    // if last comparsion result > 0 then jump to label process_block
+
+  subs    HEIGHT,  #1                      // substract 1 from HEIGHT, compare HEIGHT to 0
+  b       process_line                     // jump to label process_line
+  .fnend
+#endif
diff -Naur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp	1970-01-01 00:00:00.000000000 +0000
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp	2015-05-29 19:24:43.000000000 +0000
@@ -0,0 +1,747 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#if (defined HAVE_CONFIG_H) && (!defined WIN32)
+  #include "config.h"
+#endif
+#include "DVDVideoCodecMFC.h"
+#include "DVDDemuxers/DVDDemux.h"
+#include "DVDStreamInfo.h"
+#include "DVDClock.h"
+#include "DVDCodecs/DVDCodecs.h"
+#include "DVDCodecs/DVDCodecUtils.h"
+
+#include "utils/fastmemcpy.h"
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <dirent.h>
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CDVDVideoCodecMFC"
+
+CDVDVideoCodecMFC::CDVDVideoCodecMFC() : CDVDVideoCodec() {
+  m_v4l2MFCOutputBuffers = NULL;
+  m_v4l2MFCCaptureBuffers = NULL;
+  m_v4l2FIMCCaptureBuffers = NULL;
+
+  m_MFCOutputBuffersCount = 0;
+  m_MFCCaptureBuffersCount = 0;
+  m_FIMCCaptureBuffersCount = 0;
+
+  m_OutputPlaneU = NULL;
+  m_OutputPlaneV = NULL;
+
+  m_iDecoderHandle = -1;
+  m_iConverterHandle = -1;
+  m_bVideoConvert = false;
+  m_bDropPictures = false;
+
+  m_iDequeuedToPresentBufferNumber = -1;
+
+  memzero(m_videoBuffer);
+}
+
+CDVDVideoCodecMFC::~CDVDVideoCodecMFC() {
+  Dispose();
+}
+
+bool CDVDVideoCodecMFC::OpenDevices() {
+  DIR *dir;
+  struct dirent *ent;
+
+  if ((dir = opendir ("/sys/class/video4linux/")) != NULL) {
+    while ((ent = readdir (dir)) != NULL) {
+      if (strncmp(ent->d_name, "video", 5) == 0) {
+        char *p;
+        char name[64];
+        char devname[64];
+        char sysname[64];
+        char drivername[32];
+        char target[1024];
+        int ret;
+
+        snprintf(sysname, 64, "/sys/class/video4linux/%s", ent->d_name);
+        snprintf(name, 64, "/sys/class/video4linux/%s/name", ent->d_name);
+
+        FILE* fp = fopen(name, "r");
+        if (fgets(drivername, 32, fp) != NULL) {
+          p = strchr(drivername, '\n');
+          if (p != NULL)
+            *p = '\0';
+        } else {
+          fclose(fp);
+          continue;
+        }
+        fclose(fp);
+
+        ret = readlink(sysname, target, sizeof(target));
+        if (ret < 0)
+          continue;
+        target[ret] = '\0';
+        p = strrchr(target, '/');
+        if (p == NULL)
+          continue;
+
+        sprintf(devname, "/dev/%s", ++p);
+
+        if (m_iDecoderHandle < 0 && strncmp(drivername, "s5p-mfc-dec", 11) == 0) {
+          struct v4l2_capability cap;
+          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
+          if (fd > 0) {
+            memzero(cap);
+            ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
+            if (ret == 0)
+              if (cap.capabilities & V4L2_CAP_STREAMING &&
+                (cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
+                (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE)))) {
+                m_iDecoderHandle = fd;
+                CLog::Log(LOGDEBUG, "%s::%s - Found %s %s", CLASSNAME, __func__, drivername, devname);
+                struct v4l2_format fmt;
+                memzero(fmt);
+                fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+                fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
+                if (ioctl(m_iDecoderHandle, VIDIOC_TRY_FMT, &fmt) == 0) {
+                  CLog::Log(LOGDEBUG, "%s::%s - Direct decoding to untiled picture is supported, no conversion needed", CLASSNAME, __func__);
+                  m_iConverterHandle = -1;
+                  return true;
+                }
+              }
+          }
+          if (m_iDecoderHandle < 0)
+            close(fd);
+        }
+        if (m_iConverterHandle < 0 && strstr(drivername, "fimc") != NULL && strstr(drivername, "m2m") != NULL) {
+          struct v4l2_capability cap;
+          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
+          if (fd > 0) {
+            memzero(cap);
+            ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
+            if (ret == 0)
+              if (cap.capabilities & V4L2_CAP_STREAMING &&
+                (cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
+                (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE)))) {
+                m_iConverterHandle = fd;
+                CLog::Log(LOGDEBUG, "%s::%s - Found %s %s", CLASSNAME, __func__, drivername, devname);
+              }
+          }
+          if (m_iConverterHandle < 0)
+            close(fd);
+        }
+        if (m_iDecoderHandle >= 0 && m_iConverterHandle >= 0)
+          return true;
+      }
+    }
+    closedir (dir);
+  }
+  return false;
+}
+
+void CDVDVideoCodecMFC::Dispose() {
+
+  if (m_iConverterHandle >= 0) {
+    m_v4l2FIMCCaptureBuffers = CLinuxV4l2::FreeBuffers(m_FIMCCaptureBuffersCount, m_v4l2FIMCCaptureBuffers);
+    if (CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT Stream OFF", CLASSNAME, __func__);
+    if (CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE Stream OFF", CLASSNAME, __func__);
+
+    m_FIMCCaptureBuffersCount = 0;
+    CLog::Log(LOGDEBUG, "%s::%s - Closing FIMC", CLASSNAME, __func__);
+    close(m_iConverterHandle);
+    m_iConverterHandle = -1;
+  }
+  if (m_iDecoderHandle >= 0) {
+    m_v4l2MFCOutputBuffers = CLinuxV4l2::FreeBuffers(m_MFCOutputBuffersCount, m_v4l2MFCOutputBuffers);
+    m_v4l2MFCCaptureBuffers = CLinuxV4l2::FreeBuffers(m_MFCCaptureBuffersCount, m_v4l2MFCCaptureBuffers);
+    if (CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT Stream OFF", CLASSNAME, __func__);
+    if (CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE Stream OFF", CLASSNAME, __func__);
+
+    m_MFCOutputBuffersCount = 0;
+    m_MFCCaptureBuffersCount = 0;
+    CLog::Log(LOGDEBUG, "%s::%s - Closing MFC", CLASSNAME, __func__);
+    close(m_iDecoderHandle);
+    m_iDecoderHandle = -1;
+  }
+
+  if (m_OutputPlaneU != NULL)
+    delete[] m_OutputPlaneU;
+  if (m_OutputPlaneV != NULL)
+    delete[] m_OutputPlaneV;
+
+  m_OutputPlaneU = NULL;
+  m_OutputPlaneV = NULL;
+
+  m_iDequeuedToPresentBufferNumber = -1;
+
+  memzero(m_videoBuffer);
+
+}
+
+bool CDVDVideoCodecMFC::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) {
+  struct v4l2_format fmt;
+  struct v4l2_control ctrl;
+  struct v4l2_crop crop;
+  int ret = 0;
+  unsigned int extraSize = 0;
+  uint8_t *extraData = NULL;
+
+  m_hints = hints;
+
+  if (m_hints.software)
+    return false;
+
+  Dispose();
+  if (!OpenDevices()) {
+    CLog::Log(LOGDEBUG, "%s::%s - Needed devices not found", CLASSNAME, __func__);
+    return false;
+  }
+
+  m_bVideoConvert = m_converter.Open(m_hints.codec, (uint8_t *)m_hints.extradata, m_hints.extrasize, true);
+
+  if(m_bVideoConvert) {
+    if(m_converter.GetExtraData() != NULL && m_converter.GetExtraSize() > 0) {
+      extraSize = m_converter.GetExtraSize();
+      extraData = m_converter.GetExtraData();
+    }
+  } else {
+    if(m_hints.extrasize > 0 && m_hints.extradata != NULL) {
+      extraSize = m_hints.extrasize;
+      extraData = (uint8_t*)m_hints.extradata;
+    }
+  }
+
+  // Setup MFC OUTPUT queue (OUTPUT - name of the queue where TO encoded frames are streamed, CAPTURE - name of the queue where FROM decoded frames are taken)
+  // Set MFC OUTPUT format
+  memzero(fmt);
+  switch(m_hints.codec)
+  {
+/*
+    case CODEC_TYPE_VC1_RCV:
+      return V4L2_PIX_FMT_VC1_ANNEX_L;
+*/
+    case CODEC_ID_VC1:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_G;
+      m_name = "mfc-vc1";
+      break;
+    case CODEC_ID_MPEG1VIDEO:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG1;
+      m_name = "mfc-mpeg1";
+      break;
+    case CODEC_ID_MPEG2VIDEO:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG2;
+      m_name = "mfc-mpeg2";
+      break;
+    case CODEC_ID_MPEG4:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG4;
+      m_name = "mfc-mpeg4";
+      break;
+    case CODEC_ID_H263:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H263;
+      m_name = "mfc-h263";
+      break;
+    case CODEC_ID_H264:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264;
+      m_name = "mfc-h264";
+      break;
+    default:
+      return false;
+      break;
+  }
+  fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+  fmt.fmt.pix_mp.plane_fmt[0].sizeimage = STREAM_BUFFER_SIZE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_S_FMT, &fmt);
+  if (ret != 0) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT S_FMT failed", CLASSNAME, __func__);
+    return false;
+  }
+  // Request MFC OUTPUT buffers
+  m_MFCOutputBuffersCount = CLinuxV4l2::RequestBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, MFC_OUTPUT_BUFFERS_CNT);
+  if (m_MFCOutputBuffersCount == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT REQBUFS failed", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT REQBUFS Number of MFC buffers is %d (requested %d)", CLASSNAME, __func__, m_MFCOutputBuffersCount, MFC_OUTPUT_BUFFERS_CNT);
+
+  // Memory Map MFC OUTPUT buffers
+  m_v4l2MFCOutputBuffers = (V4L2Buffer *)calloc(m_MFCOutputBuffersCount, sizeof(V4L2Buffer));
+  if(!m_v4l2MFCOutputBuffers) {
+    CLog::Log(LOGERROR, "%s::%s - MFC cannot allocate OUTPUT buffers in memory", CLASSNAME, __func__);
+    return false;
+  }
+  if(!CLinuxV4l2::MmapBuffers(m_iDecoderHandle, m_MFCOutputBuffersCount, m_v4l2MFCOutputBuffers, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, false)) {
+    CLog::Log(LOGERROR, "%s::%s - MFC Cannot mmap OUTPUT buffers", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT Succesfully mmapped %d buffers", CLASSNAME, __func__, m_MFCOutputBuffersCount);
+
+  // Prepare header
+  m_v4l2MFCOutputBuffers[0].iBytesUsed[0] = extraSize;
+  fast_memcpy((uint8_t *)m_v4l2MFCOutputBuffers[0].cPlane[0], extraData, extraSize);
+
+  // Queue header to MFC OUTPUT queue
+  ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2MFCOutputBuffers[0]);
+  if (ret == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - MFC Error queuing header", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT <- %d header of size %d", CLASSNAME, __func__, ret, extraSize);
+
+  // STREAMON on MFC OUTPUT
+  if (!CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMON)) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT Failed to Stream ON", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT Stream ON", CLASSNAME, __func__);
+
+  // Setup MFC CAPTURE format
+  if (m_iConverterHandle < 0) {
+    memzero(fmt);
+    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+    fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
+    ret = ioctl(m_iDecoderHandle, VIDIOC_S_FMT, &fmt);
+    if (ret != 0) {
+      CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE S_FMT Failed on CAPTURE", CLASSNAME, __func__);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE S_FMT: fmt 0x%x", CLASSNAME, __func__, fmt.fmt.pix_mp.pixelformat);
+  }
+  // Get MFC CAPTURE picture format to check, and to setup FIMC converter if needed
+  memzero(fmt);
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_G_FMT, &fmt);
+  if (ret) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE G_FMT Failed", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE G_FMT: fmt 0x%x, (%dx%d), plane[0]=%d plane[1]=%d", CLASSNAME, __func__, fmt.fmt.pix_mp.pixelformat, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height, fmt.fmt.pix_mp.plane_fmt[0].sizeimage, fmt.fmt.pix_mp.plane_fmt[1].sizeimage);
+  // Size of resulting picture coming out of MFC
+  // It will be aligned by 16 since the picture is tiled
+  // We need this to know where to split buffer line by line
+  m_ResultLineSize = fmt.fmt.pix_mp.width;
+
+  // Setup FIMC OUTPUT fmt with data from MFC CAPTURE received on previous step
+  if (m_iConverterHandle >= 0) {
+    fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+    ret = ioctl(m_iConverterHandle, VIDIOC_S_FMT, &fmt);
+    if (ret != 0) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT S_FMT Failed", CLASSNAME, __func__);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT S_FMT: fmt 0x%x, (%dx%d), plane[0]=%d plane[1]=%d", CLASSNAME, __func__, fmt.fmt.pix_mp.pixelformat, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height, fmt.fmt.pix_mp.plane_fmt[0].sizeimage, fmt.fmt.pix_mp.plane_fmt[1].sizeimage);
+  }
+
+  // Get MFC needed number of buffers on CAPTURE
+  memzero(ctrl);
+  ctrl.id = V4L2_CID_MIN_BUFFERS_FOR_CAPTURE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_G_CTRL, &ctrl);
+  if (ret) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to get the number of buffers required", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE want %d buffers", CLASSNAME, __func__, ctrl.value);
+  m_MFCCaptureBuffersCount = (int)(ctrl.value * 1.5); //We need 50% more extra capture buffers for cozy decoding
+
+  // Get MFC CAPTURE crop
+  memzero(crop);
+  crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_G_CROP, &crop);
+  if (ret) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE G_CROP Failed to get crop information", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE G_CROP (%dx%d)", CLASSNAME, __func__, crop.c.width, crop.c.height);
+  // This is the picture boundaries we are interested in, everything outside is alignement because of tiled MFC output
+  m_ResultVideoWidth = crop.c.width;
+  m_ResultVideoHeight = crop.c.height;
+
+  if (m_iConverterHandle >= 0) {
+    // Setup FIMC OUTPUT crop with data from MFC CAPTURE received on previous step
+    crop.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+    if (ioctl(m_iConverterHandle, VIDIOC_S_CROP, &crop)) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT S_CROP Failed to set crop information", CLASSNAME, __func__);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT S_CROP (%dx%d)", CLASSNAME, __func__, crop.c.width, crop.c.height);
+//  FIMC scaling doesn't work good on width not a division of 16. It reports the picture to be scaled as requested,
+//  but real scale size cannot be surely determined (it is a floor of alignement to 16).
+//  I decided that than working around all this bugs it would be better to disable scaling at all. XBMC will scale picture itself good enough
+/*
+    // Calculate FIMC final picture size be scaled to fit screen
+    RESOLUTION_INFO res_info =  CDisplaySettings::Get().GetResolutionInfo(g_graphicsContext.GetVideoResolution());
+    double ratio = std::min((double)res_info.iScreenWidth / (double)m_ResultVideoWidth, (double)res_info.iScreenHeight / (double)m_ResultVideoHeight);
+    m_ResultVideoWidth = (int)((double)m_ResultVideoWidth * ratio);
+    m_ResultVideoHeight = (int)((double)m_ResultVideoHeight * ratio);
+    // Since (int) is a floor down, if resulting picture is not even, the natural way to align will be to add 1 pixel
+    if (m_ResultVideoWidth%2)
+      m_ResultVideoWidth++;
+    if (m_ResultVideoHeight%2)
+      m_ResultVideoHeight++;
+
+    CLog::Log(LOGDEBUG, "%s::%s - Scaling source Video to resulting size (%dx%d)", CLASSNAME, __func__, m_ResultVideoWidth, m_ResultVideoHeight);
+*/
+  }
+
+  // Request MFC CAPTURE buffers
+  m_MFCCaptureBuffersCount = CLinuxV4l2::RequestBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, m_MFCCaptureBuffersCount);
+  if (m_MFCCaptureBuffersCount == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE REQBUFS failed", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE REQBUFS Number of buffers is %d", CLASSNAME, __func__, m_MFCCaptureBuffersCount);
+
+  // Allocate, Memory Map and queue MFC CAPTURE buffers
+  m_v4l2MFCCaptureBuffers = (V4L2Buffer *)calloc(m_MFCCaptureBuffersCount, sizeof(V4L2Buffer));
+  if(!m_v4l2MFCCaptureBuffers) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Cannot allocate memory for buffers", CLASSNAME, __func__);
+    return false;
+  }
+  if(!CLinuxV4l2::MmapBuffers(m_iDecoderHandle, m_MFCCaptureBuffersCount, m_v4l2MFCCaptureBuffers, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, true)) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Cannot mmap memory for buffers", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE Succesfully allocated, mmapped and queued %d buffers", CLASSNAME, __func__, m_MFCCaptureBuffersCount);
+
+  // STREAMON on mfc CAPTURE
+  if (!CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMON)) {
+	CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to Stream ON", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE Stream ON", CLASSNAME, __func__);
+
+  if (m_iConverterHandle >= 0) {
+    // Request FIMC OUTPUT buffers
+    ret = CLinuxV4l2::RequestBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_USERPTR, m_MFCCaptureBuffersCount);
+    if (ret == V4L2_ERROR) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT REQBUFS failed", CLASSNAME, __func__);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT REQBUFS Number of buffers is %d", CLASSNAME, __func__, ret);
+
+    // Setup FIMC CAPTURE
+    memzero(fmt);
+    fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
+    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+    fmt.fmt.pix_mp.width = m_ResultVideoWidth;
+    fmt.fmt.pix_mp.height = m_ResultVideoHeight;
+    fmt.fmt.pix_mp.field = V4L2_FIELD_ANY;
+    ret = ioctl(m_iConverterHandle, VIDIOC_S_FMT, &fmt);
+    if (ret != 0) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE S_FMT Failed", CLASSNAME, __func__);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE S_FMT: fmt 0x%x, (%dx%d)", CLASSNAME, __func__, fmt.fmt.pix_mp.pixelformat, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height);
+
+    // Get FIMC produced picture details to adjust output buffer parameters with these values
+    memzero(fmt);
+    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+    ret = ioctl(m_iConverterHandle, VIDIOC_G_FMT, &fmt);
+    if (ret) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE G_FMT Failed", CLASSNAME, __func__);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE G_FMT: fmt 0x%x, (%dx%d), plane[0]=%d plane[1]=%d", CLASSNAME, __func__, fmt.fmt.pix_mp.pixelformat, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height, fmt.fmt.pix_mp.plane_fmt[0].sizeimage, fmt.fmt.pix_mp.plane_fmt[1].sizeimage);
+    // The length of the line on the result buffer
+    m_ResultLineSize = fmt.fmt.pix_mp.width;
+
+    memzero(crop);
+    crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+    if (ioctl(m_iConverterHandle, VIDIOC_G_CROP, &crop)) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE G_CROP Failed", CLASSNAME, __func__);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE G_CROP (%dx%d)", CLASSNAME, __func__, crop.c.width, crop.c.height);
+    // Width and Height returned after this call is the real resulting picture size produced by FIMC
+    m_ResultVideoWidth = crop.c.width;
+    m_ResultVideoHeight = crop.c.height;
+
+    // Request FIMC CAPTURE buffers
+    m_FIMCCaptureBuffersCount = CLinuxV4l2::RequestBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, FIMC_CAPTURE_BUFFERS_CNT);
+    if (m_FIMCCaptureBuffersCount == V4L2_ERROR) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE REQBUFS failed", CLASSNAME, __func__);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE REQBUFS Number of buffers is %d", CLASSNAME, __func__, m_FIMCCaptureBuffersCount);
+
+    // Allocate, Memory Map and queue FIMC CAPTURE buffers
+    m_v4l2FIMCCaptureBuffers = (V4L2Buffer *)calloc(m_FIMCCaptureBuffersCount, sizeof(V4L2Buffer));
+    if(!m_v4l2FIMCCaptureBuffers) {
+     CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Cannot allocate memory for buffers", CLASSNAME, __func__);
+     return false;
+    }
+    if(!CLinuxV4l2::MmapBuffers(m_iConverterHandle, m_FIMCCaptureBuffersCount, m_v4l2FIMCCaptureBuffers, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, true)) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Cannot mmap for capture buffers", CLASSNAME, __func__);
+      return false;
+    }
+
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE Succesfully allocated, mmapped and queued %d buffers", CLASSNAME, __func__, m_FIMCCaptureBuffersCount);
+
+    if (!CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMON)) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT Failed to Stream ON", CLASSNAME, __func__);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT Stream ON", CLASSNAME, __func__);
+    if (!CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMON)) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Failed to Stream ON", CLASSNAME, __func__);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE Stream ON", CLASSNAME, __func__);
+
+  }
+
+  m_OutputPlaneU = new BYTE[(m_ResultLineSize * m_ResultVideoHeight) >> 2];
+  m_OutputPlaneV = new BYTE[(m_ResultLineSize * m_ResultVideoHeight) >> 2];
+
+  m_videoBuffer.iFlags          = DVP_FLAG_ALLOCATED;
+
+  m_videoBuffer.color_range     = 0;
+  m_videoBuffer.color_matrix    = 4;
+
+  m_videoBuffer.iDisplayWidth   = m_ResultVideoWidth;
+  m_videoBuffer.iDisplayHeight  = m_ResultVideoHeight;
+  m_videoBuffer.iWidth          = m_ResultVideoWidth;
+  m_videoBuffer.iHeight         = m_ResultVideoHeight;
+
+  m_videoBuffer.data[0]         = NULL;
+  m_videoBuffer.data[1]         = m_OutputPlaneU;
+  m_videoBuffer.data[2]         = m_OutputPlaneV;
+  m_videoBuffer.data[3]         = NULL;
+
+  m_videoBuffer.format          = RENDER_FMT_YUV420P;
+  m_videoBuffer.iLineSize[0]    = m_ResultLineSize;
+  m_videoBuffer.iLineSize[1]    = m_ResultLineSize >> 1;
+  m_videoBuffer.iLineSize[2]    = m_ResultLineSize >> 1;
+  m_videoBuffer.iLineSize[3]    = 0;
+  m_videoBuffer.pts             = DVD_NOPTS_VALUE;
+  m_videoBuffer.dts             = DVD_NOPTS_VALUE;
+
+  CLog::Log(LOGNOTICE, "%s::%s - MFC Setup succesfull, start streaming", CLASSNAME, __func__);
+
+  return true;
+}
+
+void CDVDVideoCodecMFC::SetDropState(bool bDrop) {
+
+  CLog::Log(LOGDEBUG, "%s::%s - SetDropState %d", CLASSNAME, __func__, bDrop);
+  m_bDropPictures = bDrop;
+  if (m_bDropPictures)
+    m_videoBuffer.iFlags |=  DVP_FLAG_DROPPED;
+  else
+    m_videoBuffer.iFlags &= ~DVP_FLAG_DROPPED;
+
+}
+
+int CDVDVideoCodecMFC::Decode(BYTE* pData, int iSize, double dts, double pts) {
+  int ret = -1;
+  int index = 0;
+  double dequeuedTimestamp;
+
+  if (m_hints.ptsinvalid)
+    pts = DVD_NOPTS_VALUE;
+
+  //unsigned int dtime = XbmcThreads::SystemClockMillis();
+  CLog::Log(LOGDEBUG, "%s::%s - input frame iSize %d, pts %lf, dts %lf", CLASSNAME, __func__, iSize, pts, dts);
+
+  if(pData) {
+    int demuxer_bytes = iSize;
+    uint8_t *demuxer_content = pData;
+
+	// Find buffer ready to be filled
+    while (index < m_MFCOutputBuffersCount && m_v4l2MFCOutputBuffers[index].bQueue)
+      index++;
+
+    if (index >= m_MFCOutputBuffersCount) { //all input buffers are busy, dequeue needed
+      ret = CLinuxV4l2::PollOutput(m_iDecoderHandle, 1000/3); // Wait up to 1/3 (3 fps) sec for buffer to become available to recieve new encoded frame.
+                                                              // POLLIN - Capture, POLLOUT - Output
+      if (ret == V4L2_ERROR) {
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT PollOutput Error", CLASSNAME, __func__);
+        return VC_ERROR;
+      } else if (ret == V4L2_READY) {
+        index = CLinuxV4l2::DequeueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, &dequeuedTimestamp);
+        if (index < 0) {
+          CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, index, errno);
+          return VC_FLUSHED;
+        }
+        CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT -> %d", CLASSNAME, __func__, index);
+        m_v4l2MFCOutputBuffers[index].bQueue = false;
+      } else if (ret == V4L2_BUSY) { // buffer is still busy
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT All buffers are queued and busy, no space for new frame to decode. Very broken situation.", CLASSNAME, __func__);
+        return VC_PICTURE; // MFC is so busy it cannot accept more input frames, call ::Decode with pData = NULL to request a picture dequeue
+                           // FIXME
+                           // This will actually cause the current encoded frame to be lost in void, so this has to be fully reworked to queues storing all frames coming in
+                           // In current realization the picture will distort in this case scenarios
+      } else {
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT PollOutput error %d, errno %d", CLASSNAME, __func__, ret, errno);
+        return VC_ERROR;
+      }
+    }
+
+    if(m_bVideoConvert) {
+      m_converter.Convert(demuxer_content, demuxer_bytes);
+      demuxer_bytes = m_converter.GetConvertSize();
+      demuxer_content = m_converter.GetConvertBuffer();
+    }
+
+    if(demuxer_bytes < m_v4l2MFCOutputBuffers[index].iSize[0]) {
+      fast_memcpy((uint8_t *)m_v4l2MFCOutputBuffers[index].cPlane[0], demuxer_content, demuxer_bytes);
+      m_v4l2MFCOutputBuffers[index].iBytesUsed[0] = demuxer_bytes;
+      m_v4l2MFCOutputBuffers[index].timestamp = pts;
+
+      ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2MFCOutputBuffers[index]);
+      if (ret == V4L2_ERROR) {
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, index, errno);
+        return VC_FLUSHED;
+      }
+      CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT <- %d", CLASSNAME, __func__, index);
+    } else
+      CLog::Log(LOGERROR, "%s::%s - Packet to big for streambuffer", CLASSNAME, __func__);
+  }
+
+  if (m_iDequeuedToPresentBufferNumber >= 0) {
+    if (m_iConverterHandle >= 0) {
+     if (!m_v4l2FIMCCaptureBuffers[m_iDequeuedToPresentBufferNumber].bQueue) {
+        ret = CLinuxV4l2::QueueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2FIMCCaptureBuffers[m_iDequeuedToPresentBufferNumber]);
+        if (ret == V4L2_ERROR) {
+          CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, m_iDequeuedToPresentBufferNumber, errno);
+          return VC_FLUSHED;
+        }
+        CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE <- %d", CLASSNAME, __func__, m_iDequeuedToPresentBufferNumber);
+        m_iDequeuedToPresentBufferNumber = -1;
+      }
+    } else {
+     if (!m_v4l2MFCCaptureBuffers[m_iDequeuedToPresentBufferNumber].bQueue) {
+        ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2MFCCaptureBuffers[m_iDequeuedToPresentBufferNumber]);
+        if (ret == V4L2_ERROR) {
+          CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, m_iDequeuedToPresentBufferNumber, errno);
+          return VC_FLUSHED;
+        }
+        CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE <- %d", CLASSNAME, __func__, m_iDequeuedToPresentBufferNumber);
+        m_iDequeuedToPresentBufferNumber = -1;
+      }
+    }
+  }
+
+  // Dequeue decoded frame
+  index = CLinuxV4l2::DequeueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &dequeuedTimestamp);
+  if (index < 0) {
+    if (errno == EAGAIN) // Buffer is still busy, queue more
+      return VC_BUFFER;
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, ret, errno);
+    return VC_FLUSHED;
+  }
+  m_v4l2MFCCaptureBuffers[index].bQueue = false;
+  m_v4l2MFCCaptureBuffers[index].timestamp = dequeuedTimestamp;
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE -> %d", CLASSNAME, __func__, index);
+
+  if (m_bDropPictures) {
+    CLog::Log(LOGDEBUG, "%s::%s - Dropping frame with index %d", CLASSNAME, __func__, index);
+    // Queue it back to MFC CAPTURE since the picture is dropped anyway
+    ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2MFCCaptureBuffers[index]);
+    if (ret < 0) {
+      CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, index, errno);
+      return VC_FLUSHED;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE <- %d", CLASSNAME, __func__, index);
+    return VC_BUFFER | VC_PICTURE; // Continue, VC_PICTURE is needed for XBMC 12 to continue showing something on screen. It's a buggy behaviour
+  } else {
+    if (m_iConverterHandle >= 0) {
+      ret = CLinuxV4l2::QueueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_USERPTR, &m_v4l2MFCCaptureBuffers[index]);
+      if (ret == V4L2_ERROR) {
+        CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, ret, errno);
+        return VC_FLUSHED;
+      }
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT <- %d", CLASSNAME, __func__, index);
+
+      index = CLinuxV4l2::DequeueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &dequeuedTimestamp);
+      if (index < 0) {
+        if (errno == EAGAIN) // Dequeue buffer not ready, need more data on input. EAGAIN = 11
+          return VC_BUFFER;
+        CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, index, errno);
+        return VC_FLUSHED;
+      }
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE -> %d", CLASSNAME, __func__, index);
+
+      ret = CLinuxV4l2::DequeueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_USERPTR, &dequeuedTimestamp);
+      if (ret < 0) {
+        if (errno == EAGAIN) // Dequeue buffer not ready, need more data on input. EAGAIN = 11
+          return VC_BUFFER;
+        CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, ret, errno);
+        return VC_FLUSHED;
+      }
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT -> %d", CLASSNAME, __func__, ret);
+      // Queue it back to MFC CAPTURE
+      if (CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2MFCCaptureBuffers[ret]) < 0) {
+        CLog::Log(LOGERROR, "%s::%s - MFC queue CAPTURE buffer", CLASSNAME, __func__);
+        return VC_FLUSHED;
+      }
+      CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE <- %d", CLASSNAME, __func__, ret);
+
+      m_v4l2FIMCCaptureBuffers[index].bQueue = false;
+      m_v4l2FIMCCaptureBuffers[index].timestamp = dequeuedTimestamp;
+
+      deinterleave_chroma_neon(m_OutputPlaneU, m_OutputPlaneV, m_v4l2FIMCCaptureBuffers[index].cPlane[1], m_ResultLineSize >> 1, m_ResultVideoHeight >> 1);
+      m_videoBuffer.data[0]         = (BYTE*)m_v4l2FIMCCaptureBuffers[index].cPlane[0];
+      m_videoBuffer.pts             = m_v4l2FIMCCaptureBuffers[index].timestamp;
+    } else {
+      deinterleave_chroma_neon(m_OutputPlaneU, m_OutputPlaneV, m_v4l2MFCCaptureBuffers[index].cPlane[1], m_ResultLineSize >> 1, m_ResultVideoHeight >> 1);
+      m_videoBuffer.data[0]         = (BYTE*)m_v4l2MFCCaptureBuffers[index].cPlane[0];
+      m_videoBuffer.pts             = m_v4l2MFCCaptureBuffers[index].timestamp;
+    }
+
+    m_iDequeuedToPresentBufferNumber = index;
+  }
+
+  //msg("Decode time: %d", XbmcThreads::SystemClockMillis() - dtime);
+  return VC_PICTURE | VC_BUFFER; // Picture is finally ready to be processed further and more info can be enqueued
+}
+
+void CDVDVideoCodecMFC::Reset() {
+
+  CLog::Log(LOGERROR, "%s::%s - Codec Reset. Reinitializing", CLASSNAME, __func__);
+  CDVDCodecOptions options;
+  // We need full MFC/FIMC reset with device reopening.
+  // I wasn't able to reinitialize both IP's without fully closing and reopening them.
+  // There are always some clips that cause MFC or FIMC go into state which cannot be reset without close/open
+  Open(m_hints, options);
+
+}
+
+bool CDVDVideoCodecMFC::GetPicture(DVDVideoPicture* pDvdVideoPicture) {
+
+  CLog::Log(LOGDEBUG, "%s::%s - GetPicture", CLASSNAME, __func__);
+  *pDvdVideoPicture = m_videoBuffer;
+  CLog::Log(LOGDEBUG, "%s::%s - output frame pts %lf", CLASSNAME, __func__, m_videoBuffer.pts);
+  return true;
+
+}
+
+bool CDVDVideoCodecMFC::ClearPicture(DVDVideoPicture* pDvdVideoPicture) {
+  return CDVDVideoCodec::ClearPicture(pDvdVideoPicture);
+}
diff -Naur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h	1970-01-01 00:00:00.000000000 +0000
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h	2015-05-29 19:24:43.000000000 +0000
@@ -0,0 +1,89 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DVDVideoCodec.h"
+#include "DVDStreamInfo.h"
+#include "utils/BitstreamConverter.h"
+#include "xbmc/linux/LinuxV4l2.h"
+
+#ifndef V4L2_CAP_VIDEO_M2M_MPLANE
+  #define V4L2_CAP_VIDEO_M2M_MPLANE 0x00004000
+#endif
+
+#define STREAM_BUFFER_SIZE            1048576 //compressed frame size buffer. for unknown reason, possibly the firmware bug,
+                                              //if set to lower values it corrupts adjacent value in the setup data structure for h264 streams
+                                              //and leads to stream hangs on heavy frames
+#define FIMC_CAPTURE_BUFFERS_CNT      3 //2 begins to be slow.
+#define MFC_OUTPUT_BUFFERS_CNT        3 //1 doesn't work at all, 2 is enough most of the times, but in a rare case of interlaced video two buffers
+                                        //must be queued all the time to get fill picture from interlaced frames, so let's have them 3
+
+#define memzero(x) memset(&(x), 0, sizeof (x))
+
+void deinterleave_chroma_neon ( void *u_out, void *v_out, void *uv_in, int width, int height) asm("deinterleave_chroma_neon");
+
+class CDVDVideoCodecMFC : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecMFC();
+  virtual ~CDVDVideoCodecMFC();
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose();
+  virtual int Decode(BYTE* pData, int iSize, double dts, double pts);
+  virtual void Reset();
+  bool GetPictureCommon(DVDVideoPicture* pDvdVideoPicture);
+  virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
+
+protected:
+  std::string m_name;
+  int m_iDecoderHandle;
+  int m_iConverterHandle;
+
+  int m_MFCOutputBuffersCount;
+  int m_MFCCaptureBuffersCount;
+  int m_FIMCCaptureBuffersCount;
+
+  V4L2Buffer *m_v4l2MFCOutputBuffers;
+  V4L2Buffer *m_v4l2MFCCaptureBuffers;
+  V4L2Buffer *m_v4l2FIMCCaptureBuffers;
+
+  int m_ResultLineSize;
+  int m_ResultVideoWidth;
+  int m_ResultVideoHeight;
+
+  BYTE *m_OutputPlaneU;
+  BYTE *m_OutputPlaneV;
+
+  int m_iDequeuedToPresentBufferNumber;
+
+  bool m_bVideoConvert;
+  CDVDStreamInfo m_hints;
+
+  CBitstreamConverter m_converter;
+  bool m_bDropPictures;
+
+  DVDVideoPicture   m_videoBuffer;
+
+  bool OpenDevices();
+};
diff -Naur a/xbmc/linux/LinuxV4l2.cpp b/xbmc/linux/LinuxV4l2.cpp
--- a/xbmc/linux/LinuxV4l2.cpp	1970-01-01 00:00:00.000000000 +0000
+++ b/xbmc/linux/LinuxV4l2.cpp	2015-05-29 19:24:50.000000000 +0000
@@ -0,0 +1,309 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#if (defined HAVE_CONFIG_H) && (!defined WIN32)
+  #include "config.h"
+#endif
+#include "LinuxV4l2.h"
+
+#include "xbmc/utils/log.h"
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <linux/media.h>
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CLinuxV4l2"
+
+CLinuxV4l2::CLinuxV4l2()
+{
+}
+
+CLinuxV4l2::~CLinuxV4l2()
+{
+}
+
+int CLinuxV4l2::RequestBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, int numBuffers)
+{
+  struct v4l2_requestbuffers reqbuf;
+  int ret = 0;
+
+  if(device < 0)
+    return false;
+
+  memset(&reqbuf, 0, sizeof(struct v4l2_requestbuffers));
+
+  reqbuf.type     = type;
+  reqbuf.memory   = memory;
+  reqbuf.count    = numBuffers;
+
+  ret = ioctl(device, VIDIOC_REQBUFS, &reqbuf);
+  if (ret)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Request buffers", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+
+  return reqbuf.count;
+}
+
+bool CLinuxV4l2::StreamOn(int device, enum v4l2_buf_type type, int onoff)
+{
+  int ret = 0;
+  enum v4l2_buf_type setType = type;
+
+  if(device < 0)
+    return false;
+
+  ret = ioctl(device, onoff, &setType);
+  if(ret)
+    return false;
+
+  return true;
+}
+
+bool CLinuxV4l2::MmapBuffers(int device, int count, V4L2Buffer *v4l2Buffers, enum v4l2_buf_type type, enum v4l2_memory memory, bool queue)
+{
+  struct v4l2_buffer buf;
+  struct v4l2_plane planes[V4L2_NUM_MAX_PLANES];
+  int ret;
+  int i, j;
+
+  if(device < 0 || !v4l2Buffers || count == 0)
+    return false;
+
+  for(i = 0; i < count; i++)
+  {
+    memset(&buf, 0, sizeof(struct v4l2_buffer));
+    memset(&planes, 0, sizeof(struct v4l2_plane) * V4L2_NUM_MAX_PLANES);
+    buf.type      = type;
+    buf.memory    = memory;
+    buf.index     = i;
+    buf.m.planes  = planes;
+    buf.length    = V4L2_NUM_MAX_PLANES;
+
+    ret = ioctl(device, VIDIOC_QUERYBUF, &buf);
+    if (ret)
+    {
+      CLog::Log(LOGERROR, "%s::%s - Query buffer", CLASSNAME, __func__);
+      return false;
+    }
+
+    V4L2Buffer *buffer = &v4l2Buffers[i];
+
+    buffer->iNumPlanes = 0;
+    buffer->bQueue = false;
+    for (j = 0; j < buf.length; j++)
+    {
+      buffer->iSize[j]       = buf.m.planes[j].length;
+      buffer->iBytesUsed[j]  = buf.m.planes[j].bytesused;
+      if(buffer->iSize[j])
+      {
+        buffer->cPlane[j] = mmap(NULL, buf.m.planes[j].length, PROT_READ | PROT_WRITE,
+                       MAP_SHARED, device, buf.m.planes[j].m.mem_offset);
+        if(buffer->cPlane[j] == MAP_FAILED)
+        {
+          CLog::Log(LOGERROR, "%s::%s - Mmapping buffer", CLASSNAME, __func__);
+          return false;
+        }
+        memset(buffer->cPlane[j], 0, buf.m.planes[j].length);
+        buffer->iNumPlanes++;
+      }
+    }
+    buffer->iIndex = i;
+
+    if(queue)
+      QueueBuffer(device, type, memory, buffer);
+  }
+
+  return true;
+}
+
+V4L2Buffer *CLinuxV4l2::FreeBuffers(int count, V4L2Buffer *v4l2Buffers)
+{
+  int i, j;
+
+  if(v4l2Buffers != NULL)
+  {
+    for(i = 0; i < count; i++)
+    {
+      V4L2Buffer *buffer = &v4l2Buffers[i];
+
+      for (j = 0; j < buffer->iNumPlanes; j++)
+      {
+        if(buffer->cPlane[j] && buffer->cPlane[j] != MAP_FAILED)
+        {
+          munmap(buffer->cPlane[j], buffer->iSize[j]);
+          CLog::Log(LOGDEBUG, "%s::%s - unmap convert buffer", CLASSNAME, __func__);
+        }
+      }
+    }
+    free(v4l2Buffers);
+  }
+  return NULL;
+}
+
+int CLinuxV4l2::DequeueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, double *dequeuedTimestamp)
+{
+  struct v4l2_buffer vbuf;
+  struct v4l2_plane  vplanes[V4L2_NUM_MAX_PLANES];
+  int ret = 0;
+
+  if(device < 0)
+    return V4L2_ERROR;
+
+  memset(&vplanes, 0, sizeof(struct v4l2_plane) * V4L2_NUM_MAX_PLANES);
+  memset(&vbuf, 0, sizeof(struct v4l2_buffer));
+  vbuf.type     = type;
+  vbuf.memory   = memory;
+  vbuf.m.planes = vplanes;
+  vbuf.length   = V4L2_NUM_MAX_PLANES;
+
+  ret = ioctl(device, VIDIOC_DQBUF, &vbuf);
+  if (ret) {
+    if (errno != EAGAIN)
+      CLog::Log(LOGERROR, "%s::%s - Dequeue buffer", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+
+  if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+    // Unbox two 32-bit integers from struct timeval received from MFC back into one 64-bit double expected by XBMC as pts
+    // WARNING: It will work only if double is 64-bit and long is 32.
+    // Since MFC is IP available only in Samsung Exynos ARM's and the code is for V4L2 for linux it should work.
+    long pts[2] = { vbuf.timestamp.tv_sec, vbuf.timestamp.tv_usec };
+    *dequeuedTimestamp = *((double*)&pts[0]);;
+  }
+  return vbuf.index;
+}
+
+int CLinuxV4l2::QueueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, V4L2Buffer *buffer)
+{
+  struct v4l2_buffer vbuf;
+  struct v4l2_plane  vplanes[buffer->iNumPlanes];
+  int ret = 0;
+
+  if(!buffer || device <0)
+    return V4L2_ERROR;
+
+  memset(&vplanes, 0, sizeof(struct v4l2_plane) * buffer->iNumPlanes);
+  memset(&vbuf, 0, sizeof(struct v4l2_buffer));
+  vbuf.type     = type;
+  vbuf.memory   = memory;
+  vbuf.index    = buffer->iIndex;
+  vbuf.m.planes = vplanes;
+  vbuf.length   = buffer->iNumPlanes;
+  if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+    vbuf.flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;
+    // This will box 64-bit double given as pts from XBMC into two 32-bit integers available in struct timeval which MFC expects.
+    // WARNING: This values has nothing to do with real timestamp of the frame, it is just two 32-bit halves of 64-bit double
+    // and must be unboxed back the same way on deqeue. It will work only if double is 64-bit and long is 32.
+    // Since MFC is IP available only in Samsung Exynos ARM's, and the code is for V4L2 for linux it should work.
+    // The values will be just copied by driver from input frame to output frame and will not affect decoding in any way
+    long* pts = (long*)&buffer->timestamp;
+    vbuf.timestamp.tv_sec = pts[0];
+    vbuf.timestamp.tv_usec = pts[1];
+  }
+
+  for (int i = 0; i < buffer->iNumPlanes; i++)
+  {
+    vplanes[i].m.userptr   = (unsigned long)buffer->cPlane[i];
+    vplanes[i].length      = buffer->iSize[i];
+    vplanes[i].bytesused   = buffer->iBytesUsed[i];
+  }
+
+  ret = ioctl(device, VIDIOC_QBUF, &vbuf);
+  if (ret)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Queue buffer", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+  buffer->bQueue = true;
+
+  return vbuf.index;
+}
+
+int CLinuxV4l2::PollInput(int device, int timeout)
+{
+  int ret = 0;
+  struct pollfd p;
+  p.fd = device;
+  p.events = POLLIN | POLLERR;
+
+  ret = poll(&p, 1, timeout);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Polling input", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+  else if (ret == 0)
+  {
+    return V4L2_BUSY;
+  }
+
+  return V4L2_READY;
+}
+
+int CLinuxV4l2::PollOutput(int device, int timeout)
+{
+  int ret = 0;
+  struct pollfd p;
+  p.fd = device;
+  p.events = POLLOUT | POLLERR;
+
+  ret = poll(&p, 1, timeout);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Polling output", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+  else if (ret == 0)
+  {
+    return V4L2_BUSY;
+  }
+
+  return V4L2_READY;
+}
+
+int CLinuxV4l2::SetControllValue(int device, int id, int value)
+{
+  struct v4l2_control control;
+  int ret;
+
+  control.id    = id;
+  control.value = value;
+
+  ret = ioctl(device, VIDIOC_S_CTRL, &control);
+
+  if(ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Set controll if %d value %d\n", CLASSNAME, __func__, id, value);
+    return V4L2_ERROR;
+  }
+
+  return V4L2_OK;
+}
diff -Naur a/xbmc/linux/LinuxV4l2.h b/xbmc/linux/LinuxV4l2.h
--- a/xbmc/linux/LinuxV4l2.h	1970-01-01 00:00:00.000000000 +0000
+++ b/xbmc/linux/LinuxV4l2.h	2015-05-29 19:24:50.000000000 +0000
@@ -0,0 +1,77 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/videodev2.h>
+
+#ifndef V4L2_BUF_FLAG_TIMESTAMP_COPY
+  #define V4L2_BUF_FLAG_TIMESTAMP_COPY 0x4000
+#endif
+
+#define V4L2_ERROR -1
+#define V4L2_BUSY  1
+#define V4L2_READY 2
+#define V4L2_OK    3
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define V4L2_NUM_MAX_PLANES 3
+
+typedef struct V4L2Buffer
+{
+  int   iSize[V4L2_NUM_MAX_PLANES];
+  int   iOffset[V4L2_NUM_MAX_PLANES];
+  int   iBytesUsed[V4L2_NUM_MAX_PLANES];
+  void  *cPlane[V4L2_NUM_MAX_PLANES];
+  int   iNumPlanes;
+  int   iIndex;
+  bool  bQueue;
+  double timestamp;
+} V4L2Buffer;
+
+#ifdef __cplusplus
+}
+#endif
+
+class CLinuxV4l2
+{
+public:
+  CLinuxV4l2();
+  virtual ~CLinuxV4l2();
+
+  static int RequestBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, int numBuffers);
+  static bool StreamOn(int device, enum v4l2_buf_type type, int onoff);
+  static bool MmapBuffers(int device, int count, V4L2Buffer *v4l2Buffers, enum v4l2_buf_type type, enum v4l2_memory memory, bool queue = true);
+  static V4L2Buffer *FreeBuffers(int count, V4L2Buffer *v4l2Buffers);
+
+  static int DequeueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, double *dequeuedTimestamp);
+  static int QueueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, V4L2Buffer *buffer);
+
+  static int PollInput(int device, int timeout);
+  static int PollOutput(int device, int timeout);
+  static int SetControllValue(int device, int id, int value);
+};
+
+inline int v4l2_align(int v, int a) {
+  return ((v + a - 1) / a) * a;
+}
